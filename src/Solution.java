import java.util.ArrayList;
import java.util.List;

public class Solution {

    /*** PART ONE ***/

    // Когда подводная лодка опускается ниже поверхности океана,
    // она автоматически выполняет гидролокационное сканирование близлежащего морского дна.
    // На маленьком экране появляется отчет о сканировании гидролокатором (ваш ввод головоломки):
    // каждая строка представляет собой измерение глубины морского дна по мере того,
    // как сканирование смотрит все дальше и дальше от подводной лодки.
    // Например, предположим, что у вас есть следующий отчет:
    //
    // 199
    // 200
    // 208
    // 210
    // 200
    // 207
    // 240
    // 269
    // 260
    // 263
    //
    // В этом отчете указано, что при сканировании в направлении от подводной лодки
    // гидролокатор обнаружил глубины 199, 200, 208, 210 и так далее.
    //
    // Первое, что нужно сделать, это выяснить, как быстро увеличивается глубина, просто чтобы вы знали,
    // с чем имеете дело — никогда не знаешь, унесут ли ключи в более глубокие воды океанское течение,
    // или рыба, или что-то в этом роде.
    //
    // Для этого подсчитайте, во сколько раз измерение глубины увеличивается по сравнению с предыдущим измерением.
    // (Перед первым измерением нет измерений.)
    // В приведенном ниже примере изменения следующие:
    //
    // 199 (Н/Д - нет предыдущих измерений)
    // 200 (увеличено)
    // 208 (увеличено)
    // 210 (увеличено)
    // 200 (уменьшено)
    // 207 (увеличено)
    // 240 (увеличено)
    // 269 (увеличено)
    // 260 (уменьшено)
    // 263 (увеличено)
    // В этом примере есть 7 измерений, которые больше, чем предыдущее измерение.
    //
    // Сколько измерений больше, чем предыдущее измерение?

    /*** PART TWO ***/

    // Учет каждого отдельного измерения не так полезен, как вы ожидали: слишком много шума в данных.
    //
    // Вместо этого рассмотрите суммы трехмерного скользящего окна. Опять же, учитывая приведенный выше пример:
    //
    // 199 А
    // 200 А B
    // 208 А B C
    // 210   B C D
    // 200     C D E
    // 207       D E F
    // 240         E F G
    // 269           F G H
    // 260             G H
    // 263               H
    //
    // Начните со сравнения первого и второго трехмерных окон.
    // Измерения в первом окне отмечены буквой А (199, 200, 208); их сумма 199 + 200 + 208 = 607.
    // Второе окно отмечено буквой B (200, 208, 210); его сумма равна 618.
    // Сумма измерений во втором окне больше, чем сумма в первом, поэтому это первое сравнение увеличилось.
    //
    // Теперь ваша цель состоит в том, чтобы подсчитать,
    // Cколько раз сумма измерений в этом скользящем окне увеличивается по сравнению с предыдущей суммой.
    // Итак, сравните A с B, затем сравните B с C, затем C с D и так далее.
    // Остановитесь, когда останется недостаточно измерений для создания новой суммы трех измерений.
    //
    // В приведенном выше примере сумма каждого окна с тремя измерениями выглядит следующим образом:
    //
    // A: 607 (Н/Д - нет предыдущей суммы)
    // В: 618 (увеличено)
    // С: 618 (без изменений)
    // D: 617 (уменьшено)
    // Е: 647 (увеличено)
    // F: 716 (увеличено)
    // G: 769 (увеличено)
    // H: 792 (увеличено)
    // В этом примере есть 5 сумм, которые больше, чем предыдущая сумма.
    //
    // Рассмотрим суммы трехмерного скользящего окна. Сколько сумм больше предыдущей суммы?

    /*** PART THREE ***/

    // "Быстрая сортировка", хоть и была разработана более 40 лет назад, является наиболее широко применяемым
    // и одним их самых эффективных алгоритмов.
    //
    // Метод основан на подходе "разделяй-и-властвуй". Общая схема такова:
    //
    // из массива выбирается некоторый опорный элемент a[i],
    // запускается процедура разделения массива, которая перемещает все ключи, меньшие, либо равные a[i], влево от него,
    // а все ключи, большие, либо равные a[i] - вправо,
    // теперь массив состоит из двух подмножеств, причем левое меньше, либо равно правого,
    //
    // для обоих подмассивов: если в подмассиве более двух элементов, рекурсивно запускаем для него ту же процедуру.
    // В конце получится полностью отсортированная последовательность.


    public static void main(String[] args) {
        List<Integer> depths = new ArrayList<>(Input.INPUT);

        System.out.println(countDepths(depths));

        // Part two

        List<Integer> triplets = triplets(depths);

        System.out.println(countDepths(triplets));

        // Part three

        quickSort(triplets, 0, triplets.size() - 1);

        isSorted(triplets);
    }

    private static void isSorted(List<Integer> list) {
        for (int i = 0; i < list.size() - 1; i++) {
            if (list.get(i) > list.get(i + 1)) {
                System.out.println("Не отсортирован");
                return;
            }
        }
        System.out.println("Отсортирован");
    }

    private static void quickSort(List<Integer> list, int low, int high) {
       if (low < high) {
           int pivot = divide(list, low, high);

           quickSort(list, low, pivot - 1);
           quickSort(list, pivot + 1, high);
       }
    }

    private static int divide(List<Integer> list, int low, int high) {
        int pivot = list.get(high);
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (list.get(j) <= pivot) {
                i++;
                swap(list, i, j);
            }
        }
        swap(list, i + 1, high);
        return i + 1;
    }

    private static void swap(List<Integer> list, int i, int j) {
        int temp = list.get(i);

        list.set(i, list.get(j));
        list.set(j, temp);
    }

    private static int countDepths(List<Integer> depths) {
        int count = 0;

        for (int i = 1; i < depths.size(); i++) {
            if (depths.get(i) > depths.get(i - 1)) {
                count++;
            }
        }

        return count;
    }

    private static List<Integer> triplets(List<Integer> list) {
        List<Integer> tripletsSum = new ArrayList<>();

        for (int i = 0; i < list.size() - 2; i++) {
            tripletsSum.add(list.get(i) + list.get(i + 1) + list.get(i + 2));
        }

        return tripletsSum;
    }
}
